{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django API Forms \u00b6 Django Forms approach in the processing of a RESTful HTTP request payload (especially for content type like JSON or MessagePack ) without HTML front-end. Motivation \u00b6 The main idea was to create a simple and declarative way to specify the format of expecting requests with the ability to validate them. Firstly, I tried to use Django Forms to validate my API requests (I use pure Django in my APIs). I have encountered a problem with nesting my requests without a huge boilerplate. Also, the whole HTML thing was pretty useless in my RESTful APIs. I wanted to: define my requests as object ( Form ), pass the request to my defined object ( form = Form.create_from_request(request) ), validate my request form.is_valid() , extract data form.clean_data property. I wanted to keep: friendly declarative Django syntax, ( DeclarativeFieldsMetaclass is beautiful), Validators , ValidationError , Form fields (In the end, I had to \"replace\" some of them). So I have decided to create a simple Python package to cover all my expectations. Running Tests \u00b6 # install all dependencies poetry install # run code-style check poetry run flake8 . # run the tests poetry run python runtests.py","title":"Home"},{"location":"#django-api-forms","text":"Django Forms approach in the processing of a RESTful HTTP request payload (especially for content type like JSON or MessagePack ) without HTML front-end.","title":"Django API Forms"},{"location":"#motivation","text":"The main idea was to create a simple and declarative way to specify the format of expecting requests with the ability to validate them. Firstly, I tried to use Django Forms to validate my API requests (I use pure Django in my APIs). I have encountered a problem with nesting my requests without a huge boilerplate. Also, the whole HTML thing was pretty useless in my RESTful APIs. I wanted to: define my requests as object ( Form ), pass the request to my defined object ( form = Form.create_from_request(request) ), validate my request form.is_valid() , extract data form.clean_data property. I wanted to keep: friendly declarative Django syntax, ( DeclarativeFieldsMetaclass is beautiful), Validators , ValidationError , Form fields (In the end, I had to \"replace\" some of them). So I have decided to create a simple Python package to cover all my expectations.","title":"Motivation"},{"location":"#running-tests","text":"# install all dependencies poetry install # run code-style check poetry run flake8 . # run the tests poetry run python runtests.py","title":"Running Tests"},{"location":"example/","text":"Example \u00b6 Settings \u00b6 DJANGO_API_FORMS_POPULATION_STRATEGIES = { 'django_api_forms.fields.FormFieldList' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django_api_forms.fields.FileField' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django_api_forms.fields.ImageField' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django_api_forms.fields.FormField' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django.forms.models.ModelMultipleChoiceField' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django.forms.models.ModelChoiceField' : 'django_api_forms.population_strategies.ModelChoiceFieldStrategy' } DJANGO_API_FORMS_DEFAULT_POPULATION_STRATEGY = 'django_api_forms.population_strategies.BaseStrategy' DJANGO_API_FORMS_PARSERS = { 'application/json' : 'json.loads' , 'application/x-msgpack' : 'msgpack.loads' } JSON request \u00b6 { \"title\" : \"Unknown Pleasures\" , \"type\" : \"vinyl\" , \"artist\" : { \"_name\" : \"Joy Division\" , \"genres\" : [ \"rock\" , \"punk\" ], \"members\" : 4 }, \"year\" : 1979 , \"songs\" : [ { \"title\" : \"Disorder\" , \"duration\" : \"3:29\" }, { \"title\" : \"Day of the Lords\" , \"duration\" : \"4:48\" , \"metadata\" : { \"_section\" : { \"type\" : \"ID3v2\" , \"offset\" : 0 , \"byteLength\" : 2048 }, \"header\" : { \"majorVersion\" : 3 , \"minorRevision\" : 0 , \"flagsOctet\" : 0 , \"unsynchronisationFlag\" : false , \"extendedHeaderFlag\" : false , \"experimentalIndicatorFlag\" : false , \"size\" : 2038 } } } ], \"metadata\" : { \"created_at\" : \"2019-10-21T18:57:03+0100\" , \"updated_at\" : \"2019-10-21T18:57:03+0100\" } } Python implementation \u00b6 from enum import Enum from django.core.exceptions import ValidationError from django.forms import fields from django_api_forms import FieldList , FormField , FormFieldList , DictionaryField , EnumField , AnyField , Form class AlbumType ( Enum ): CD = 'cd' VINYL = 'vinyl' class ArtistForm ( Form ): class Meta : mapping = { '_name' : 'name' } name = fields . CharField ( required = True , max_length = 100 ) genres = FieldList ( field = fields . CharField ( max_length = 30 )) members = fields . IntegerField () class SongForm ( Form ): title = fields . CharField ( required = True , max_length = 100 ) duration = fields . DurationField ( required = False ) metadata = AnyField ( required = False ) class AlbumForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () artist = FormField ( form = ArtistForm ) songs = FormFieldList ( form = SongForm ) type = EnumField ( enum = AlbumType , required = True ) metadata = DictionaryField ( fields . DateTimeField ()) def clean_year ( self ): if self . cleaned_data [ 'year' ] == 1992 : raise ValidationError ( \"Year 1992 is forbidden!\" , 'forbidden-value' ) return self . cleaned_data [ 'year' ] def clean ( self ): if ( self . cleaned_data [ 'year' ] == 1998 ) and ( self . cleaned_data [ 'artist' ][ 'name' ] == \"Nirvana\" ): raise ValidationError ( \"Sounds like a bullshit\" , code = 'time-traveling' ) return self . cleaned_data \"\"\" Django view example \"\"\" def create_album ( request ): form = AlbumForm . create_from_request ( request ) if not form . is_valid (): # Process your validation error print ( form . errors ) # Cleaned valid payload payload = form . cleaned_data print ( payload )","title":"Example"},{"location":"example/#example","text":"","title":"Example"},{"location":"example/#settings","text":"DJANGO_API_FORMS_POPULATION_STRATEGIES = { 'django_api_forms.fields.FormFieldList' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django_api_forms.fields.FileField' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django_api_forms.fields.ImageField' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django_api_forms.fields.FormField' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django.forms.models.ModelMultipleChoiceField' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django.forms.models.ModelChoiceField' : 'django_api_forms.population_strategies.ModelChoiceFieldStrategy' } DJANGO_API_FORMS_DEFAULT_POPULATION_STRATEGY = 'django_api_forms.population_strategies.BaseStrategy' DJANGO_API_FORMS_PARSERS = { 'application/json' : 'json.loads' , 'application/x-msgpack' : 'msgpack.loads' }","title":"Settings"},{"location":"example/#json-request","text":"{ \"title\" : \"Unknown Pleasures\" , \"type\" : \"vinyl\" , \"artist\" : { \"_name\" : \"Joy Division\" , \"genres\" : [ \"rock\" , \"punk\" ], \"members\" : 4 }, \"year\" : 1979 , \"songs\" : [ { \"title\" : \"Disorder\" , \"duration\" : \"3:29\" }, { \"title\" : \"Day of the Lords\" , \"duration\" : \"4:48\" , \"metadata\" : { \"_section\" : { \"type\" : \"ID3v2\" , \"offset\" : 0 , \"byteLength\" : 2048 }, \"header\" : { \"majorVersion\" : 3 , \"minorRevision\" : 0 , \"flagsOctet\" : 0 , \"unsynchronisationFlag\" : false , \"extendedHeaderFlag\" : false , \"experimentalIndicatorFlag\" : false , \"size\" : 2038 } } } ], \"metadata\" : { \"created_at\" : \"2019-10-21T18:57:03+0100\" , \"updated_at\" : \"2019-10-21T18:57:03+0100\" } }","title":"JSON request"},{"location":"example/#python-implementation","text":"from enum import Enum from django.core.exceptions import ValidationError from django.forms import fields from django_api_forms import FieldList , FormField , FormFieldList , DictionaryField , EnumField , AnyField , Form class AlbumType ( Enum ): CD = 'cd' VINYL = 'vinyl' class ArtistForm ( Form ): class Meta : mapping = { '_name' : 'name' } name = fields . CharField ( required = True , max_length = 100 ) genres = FieldList ( field = fields . CharField ( max_length = 30 )) members = fields . IntegerField () class SongForm ( Form ): title = fields . CharField ( required = True , max_length = 100 ) duration = fields . DurationField ( required = False ) metadata = AnyField ( required = False ) class AlbumForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () artist = FormField ( form = ArtistForm ) songs = FormFieldList ( form = SongForm ) type = EnumField ( enum = AlbumType , required = True ) metadata = DictionaryField ( fields . DateTimeField ()) def clean_year ( self ): if self . cleaned_data [ 'year' ] == 1992 : raise ValidationError ( \"Year 1992 is forbidden!\" , 'forbidden-value' ) return self . cleaned_data [ 'year' ] def clean ( self ): if ( self . cleaned_data [ 'year' ] == 1998 ) and ( self . cleaned_data [ 'artist' ][ 'name' ] == \"Nirvana\" ): raise ValidationError ( \"Sounds like a bullshit\" , code = 'time-traveling' ) return self . cleaned_data \"\"\" Django view example \"\"\" def create_album ( request ): form = AlbumForm . create_from_request ( request ) if not form . is_valid (): # Process your validation error print ( form . errors ) # Cleaned valid payload payload = form . cleaned_data print ( payload )","title":"Python implementation"},{"location":"fields/","text":"Fields \u00b6 Even if we tried to keep most of the native Django fields, we had to override some of them to be more fit for RESTful applications. Also, we introduced new ones, to cover extra functionality like nested requests. In this section, we will explain our intentions and describe their usage. To sum up: You can use Django Form Fields : CharField ChoiceField TypedChoiceField DateField DateTimeField DecimalField DurationField EmailField FilePathField FloatField IntegerField GenericIPAddressField MultipleChoiceField TypedMultipleChoiceField RegexField SlugField TimeField URLField UUIDField ModelChoiceField ModelMultipleChoiceField You can use Django Validators . Fields that are not in the list above were not been tested or been replaced with our customized implementation (or it just doesn't make sense to use them in RESTful APIs). BooleanField \u00b6 Normalizes to: A Python True or False value (or None if it's not required) Django BooleanField checks only for False ( false , 0 ) values and everything else is suppose to be True . In my point of view this kind of behaviour it's little bit weird, so we decided to check explicitly for True and False values. If field is required ValidationError is raised or value is normalized as None . Checked values: True : True 'True' 'true' 1 '1' False : False 'False' 'false' 0 '0' Note: We would like to change this behaviour to support only boolean values and rely on deserializers. FieldList \u00b6 This field is used to parse list of primitive values (like strings or numbers). If you want to parse list of object, check FormFieldList . Normalizes to: A Python list Error message keys: not_field , not_list , min_length , max_length Required arguments: field : Instance of a form field representing children Optional arguments: min_length : Minimum length of field size as integer max_length : Maximum length of field size as integer JSON example { \"numbers\" : [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 ] } Python representation from django_api_forms import Form , FieldList from django.forms import fields class FibonacciForm ( Form ): numbers = FieldList ( field = fields . IntegerField ()) FormField \u00b6 Field used for embedded objects represented as another API form. Normalizes to: A Python dictionary Required arguments: form : Type of a nested form JSON example { \"title\" : \"Unknown Pleasures\" , \"year\" : 1979 , \"artist\" : { \"name\" : \"Joy Division\" , \"genres\" : [ \"rock\" , \"punk\" ], \"members\" : 4 } } Python representation from django_api_forms import Form , FormField , FieldList from django.forms import fields class ArtistForm ( Form ): name = fields . CharField ( required = True , max_length = 100 ) genres = FieldList ( field = fields . CharField ( max_length = 30 )) members = fields . IntegerField () class AlbumForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () artist = FormField ( form = ArtistForm ) FormFieldList \u00b6 Field used for embedded objects represented as another API form. Normalizes to: A Python list of dictionaries Error message keys: not_list , min_length , max_length Required arguments: form : Type of a nested form Optional arguments: min_length : Minimum length of field size as integer max_length : Maximum length of field size as integer JSON example { \"title\" : \"Rock For People\" , \"artists\" : [ { \"name\" : \"Joy Division\" , \"genres\" : [ \"rock\" , \"punk\" ], \"members\" : 4 } ] } Python representation from django_api_forms import Form , FormFieldList , FieldList from django.forms import fields class ArtistForm ( Form ): name = fields . CharField ( required = True , max_length = 100 ) genres = FieldList ( field = fields . CharField ( max_length = 30 )) members = fields . IntegerField () class FestivalForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () artists = FormFieldList ( form = ArtistForm ) EnumField \u00b6 Tip : Django has pretty cool implementation of the enumeration types . Normalizes to: A Python Enum object Error message keys: not_enum , invalid Required arguments: enum : Enum class JSON example { \"title\" : \"Rock For People\" , \"type\" : \"vinyl\" } Python representation from django_api_forms import Form , EnumField from django.forms import fields from django.db.models import TextChoices class AlbumType ( TextChoices ): CD = 'cd' , 'CD' VINYL = 'vinyl' , 'Vinyl' class AlbumForm ( Form ): title = fields . CharField ( required = True , max_length = 100 ) type = EnumField ( enum = AlbumType ) DictionaryField \u00b6 Field created for containing typed value pairs (currently library supports only value validation, see Key validation in DictionaryField ). Normalizes to: A Python dictionary Error message keys: not_dict Required arguments: value_field : Type of a nested form JSON example { \"my_dict\" : { \"b061bb03-1eaa-47d0-948f-3ce1f15bf3bb\" : 2.718 , \"0a8912f0-6c10-4505-bc27-bbb099d2e395\" : 42 } } Python representation from django_api_forms import Form , DictionaryField from django.forms import fields class DictionaryForm ( Form ): my_typed_dict = DictionaryField ( value_field = fields . DecimalField ()) AnyField \u00b6 Field without default validators. Normalizes to: Type according to the chosen request payload parser JSON example { \"singer\" : { \"name\" : \"Johnny\" , \"surname\" : \"Rotten\" , \"age\" : 64 , \"born_at\" : \"1956-01-31\" } } Python representation from django_api_forms import Form , DictionaryField , AnyField class BandForm ( Form ): singer = DictionaryField ( value_field = AnyField ()) FileField \u00b6 This field contains BASE64 encoded file. Normalizes to: A Django File object Error message keys: max_length , invalid_uri , invalid_mime Arguments: max_length : Maximum files size in bytes (optional) mime : Tuple of allowed mime types (optional - if present, value must be in form of Data URI ) Extra normalised attributes: file_field.clean(payload).content_type : Mime type ( str - e.g. audio/mpeg ) of containing file ( None if unable to detect - if payload is not in DATA URI format) JSON example { \"title\" : \"Disorder\" , \"type\" : \"data:audio/mpeg;base64,SGVsbG8sIFdvcmxkIQ==\" } Python representation from django_api_forms import Form , FileField from django.conf import settings from django.forms import fields class SongForm ( Form ): title = fields . CharField ( required = True , max_length = 100 ) audio = FileField ( max_length = settings . DATA_UPLOAD_MAX_MEMORY_SIZE , mime = ( 'audio/mpeg' , )) ImageField \u00b6 This field contains BASE64 encoded image. Depends on Pillow because normalized value contains Image object. Pillow is also used for image validation Image.verify() is called. Normalizes to: A Django File object Error message keys: max_length , invalid_uri , invalid_mime , invalid_image (if Image.verify() failed) Arguments: max_length : Maximum files size in bytes (optional) mime : Tuple of allowed mime types (optional, value must be in Data URI ) Extra normalised attributes: image_field.clean(payload).content_type : Mime type ( str - e.g. audio/mpeg ) of containing file ( None if unable to detect - if payload is not in DATA URI format). Value is filled using Pillow Image.MIME.get(image.format) ) image_field.clean(payload).image : A Pillow Image object instance JSON example { \"title\" : \"Unknown pleasures\" , \"cover\" : \"data:image/png;base64,SGVsbG8sIFdvcmxkIQ==\" } Python representation from django_api_forms import Form , ImageField from django.conf import settings from django.forms import fields class AlbumForm ( Form ): title = fields . CharField ( required = True , max_length = 100 ) cover = ImageField ( max_length = settings . DATA_UPLOAD_MAX_MEMORY_SIZE , mime = ( 'image/png' , ))","title":"Fields"},{"location":"fields/#fields","text":"Even if we tried to keep most of the native Django fields, we had to override some of them to be more fit for RESTful applications. Also, we introduced new ones, to cover extra functionality like nested requests. In this section, we will explain our intentions and describe their usage. To sum up: You can use Django Form Fields : CharField ChoiceField TypedChoiceField DateField DateTimeField DecimalField DurationField EmailField FilePathField FloatField IntegerField GenericIPAddressField MultipleChoiceField TypedMultipleChoiceField RegexField SlugField TimeField URLField UUIDField ModelChoiceField ModelMultipleChoiceField You can use Django Validators . Fields that are not in the list above were not been tested or been replaced with our customized implementation (or it just doesn't make sense to use them in RESTful APIs).","title":"Fields"},{"location":"fields/#booleanfield","text":"Normalizes to: A Python True or False value (or None if it's not required) Django BooleanField checks only for False ( false , 0 ) values and everything else is suppose to be True . In my point of view this kind of behaviour it's little bit weird, so we decided to check explicitly for True and False values. If field is required ValidationError is raised or value is normalized as None . Checked values: True : True 'True' 'true' 1 '1' False : False 'False' 'false' 0 '0' Note: We would like to change this behaviour to support only boolean values and rely on deserializers.","title":"BooleanField"},{"location":"fields/#fieldlist","text":"This field is used to parse list of primitive values (like strings or numbers). If you want to parse list of object, check FormFieldList . Normalizes to: A Python list Error message keys: not_field , not_list , min_length , max_length Required arguments: field : Instance of a form field representing children Optional arguments: min_length : Minimum length of field size as integer max_length : Maximum length of field size as integer JSON example { \"numbers\" : [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 ] } Python representation from django_api_forms import Form , FieldList from django.forms import fields class FibonacciForm ( Form ): numbers = FieldList ( field = fields . IntegerField ())","title":"FieldList"},{"location":"fields/#formfield","text":"Field used for embedded objects represented as another API form. Normalizes to: A Python dictionary Required arguments: form : Type of a nested form JSON example { \"title\" : \"Unknown Pleasures\" , \"year\" : 1979 , \"artist\" : { \"name\" : \"Joy Division\" , \"genres\" : [ \"rock\" , \"punk\" ], \"members\" : 4 } } Python representation from django_api_forms import Form , FormField , FieldList from django.forms import fields class ArtistForm ( Form ): name = fields . CharField ( required = True , max_length = 100 ) genres = FieldList ( field = fields . CharField ( max_length = 30 )) members = fields . IntegerField () class AlbumForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () artist = FormField ( form = ArtistForm )","title":"FormField"},{"location":"fields/#formfieldlist","text":"Field used for embedded objects represented as another API form. Normalizes to: A Python list of dictionaries Error message keys: not_list , min_length , max_length Required arguments: form : Type of a nested form Optional arguments: min_length : Minimum length of field size as integer max_length : Maximum length of field size as integer JSON example { \"title\" : \"Rock For People\" , \"artists\" : [ { \"name\" : \"Joy Division\" , \"genres\" : [ \"rock\" , \"punk\" ], \"members\" : 4 } ] } Python representation from django_api_forms import Form , FormFieldList , FieldList from django.forms import fields class ArtistForm ( Form ): name = fields . CharField ( required = True , max_length = 100 ) genres = FieldList ( field = fields . CharField ( max_length = 30 )) members = fields . IntegerField () class FestivalForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () artists = FormFieldList ( form = ArtistForm )","title":"FormFieldList"},{"location":"fields/#enumfield","text":"Tip : Django has pretty cool implementation of the enumeration types . Normalizes to: A Python Enum object Error message keys: not_enum , invalid Required arguments: enum : Enum class JSON example { \"title\" : \"Rock For People\" , \"type\" : \"vinyl\" } Python representation from django_api_forms import Form , EnumField from django.forms import fields from django.db.models import TextChoices class AlbumType ( TextChoices ): CD = 'cd' , 'CD' VINYL = 'vinyl' , 'Vinyl' class AlbumForm ( Form ): title = fields . CharField ( required = True , max_length = 100 ) type = EnumField ( enum = AlbumType )","title":"EnumField"},{"location":"fields/#dictionaryfield","text":"Field created for containing typed value pairs (currently library supports only value validation, see Key validation in DictionaryField ). Normalizes to: A Python dictionary Error message keys: not_dict Required arguments: value_field : Type of a nested form JSON example { \"my_dict\" : { \"b061bb03-1eaa-47d0-948f-3ce1f15bf3bb\" : 2.718 , \"0a8912f0-6c10-4505-bc27-bbb099d2e395\" : 42 } } Python representation from django_api_forms import Form , DictionaryField from django.forms import fields class DictionaryForm ( Form ): my_typed_dict = DictionaryField ( value_field = fields . DecimalField ())","title":"DictionaryField"},{"location":"fields/#anyfield","text":"Field without default validators. Normalizes to: Type according to the chosen request payload parser JSON example { \"singer\" : { \"name\" : \"Johnny\" , \"surname\" : \"Rotten\" , \"age\" : 64 , \"born_at\" : \"1956-01-31\" } } Python representation from django_api_forms import Form , DictionaryField , AnyField class BandForm ( Form ): singer = DictionaryField ( value_field = AnyField ())","title":"AnyField"},{"location":"fields/#filefield","text":"This field contains BASE64 encoded file. Normalizes to: A Django File object Error message keys: max_length , invalid_uri , invalid_mime Arguments: max_length : Maximum files size in bytes (optional) mime : Tuple of allowed mime types (optional - if present, value must be in form of Data URI ) Extra normalised attributes: file_field.clean(payload).content_type : Mime type ( str - e.g. audio/mpeg ) of containing file ( None if unable to detect - if payload is not in DATA URI format) JSON example { \"title\" : \"Disorder\" , \"type\" : \"data:audio/mpeg;base64,SGVsbG8sIFdvcmxkIQ==\" } Python representation from django_api_forms import Form , FileField from django.conf import settings from django.forms import fields class SongForm ( Form ): title = fields . CharField ( required = True , max_length = 100 ) audio = FileField ( max_length = settings . DATA_UPLOAD_MAX_MEMORY_SIZE , mime = ( 'audio/mpeg' , ))","title":"FileField"},{"location":"fields/#imagefield","text":"This field contains BASE64 encoded image. Depends on Pillow because normalized value contains Image object. Pillow is also used for image validation Image.verify() is called. Normalizes to: A Django File object Error message keys: max_length , invalid_uri , invalid_mime , invalid_image (if Image.verify() failed) Arguments: max_length : Maximum files size in bytes (optional) mime : Tuple of allowed mime types (optional, value must be in Data URI ) Extra normalised attributes: image_field.clean(payload).content_type : Mime type ( str - e.g. audio/mpeg ) of containing file ( None if unable to detect - if payload is not in DATA URI format). Value is filled using Pillow Image.MIME.get(image.format) ) image_field.clean(payload).image : A Pillow Image object instance JSON example { \"title\" : \"Unknown pleasures\" , \"cover\" : \"data:image/png;base64,SGVsbG8sIFdvcmxkIQ==\" } Python representation from django_api_forms import Form , ImageField from django.conf import settings from django.forms import fields class AlbumForm ( Form ): title = fields . CharField ( required = True , max_length = 100 ) cover = ImageField ( max_length = settings . DATA_UPLOAD_MAX_MEMORY_SIZE , mime = ( 'image/png' , ))","title":"ImageField"},{"location":"install/","text":"Installation \u00b6 Library is published on PyPi index as django-api-forms . You can add it to your project using your favorite package manager. Few examples: # Using pip pip install django-api-forms # Using poetry peotry add django-api-forms # Using pipenv pipenv install django-api-forms # Local installation python -m pip install . Extra functionality \u00b6 If you want to use some extra functionality, you have to install additional dependencies. msgpack \u00b6 Library checks for application/x-msgpack HTTP content type. To work it properly you have to install msgpack . We support extras_require , so you can do it by executing pip install django-api-forms[msgpack] while installing django-api-forms or individually by pip install msgpack inside your environment. Pillow \u00b6 Library provides FileField and ImageField , which are pretty similar to Django native implementation . There fields require Pillow to be installed inside of your environment. pip install django-api-forms[Pillow] pip install Pillow Fun fact \u00b6 You can install all extra dependencies using one call pip install django-api-forms[Pillow,msgpack] .","title":"Installation"},{"location":"install/#installation","text":"Library is published on PyPi index as django-api-forms . You can add it to your project using your favorite package manager. Few examples: # Using pip pip install django-api-forms # Using poetry peotry add django-api-forms # Using pipenv pipenv install django-api-forms # Local installation python -m pip install .","title":"Installation"},{"location":"install/#extra-functionality","text":"If you want to use some extra functionality, you have to install additional dependencies.","title":"Extra functionality"},{"location":"install/#msgpack","text":"Library checks for application/x-msgpack HTTP content type. To work it properly you have to install msgpack . We support extras_require , so you can do it by executing pip install django-api-forms[msgpack] while installing django-api-forms or individually by pip install msgpack inside your environment.","title":"msgpack"},{"location":"install/#pillow","text":"Library provides FileField and ImageField , which are pretty similar to Django native implementation . There fields require Pillow to be installed inside of your environment. pip install django-api-forms[Pillow] pip install Pillow","title":"Pillow"},{"location":"install/#fun-fact","text":"You can install all extra dependencies using one call pip install django-api-forms[Pillow,msgpack] .","title":"Fun fact"},{"location":"tutorial/","text":"Tutorial \u00b6 This library helps you to handle basic RESTful API use-cases with Django Forms fashion. Library kinda replaces django.forms.Form with django_api_forms.Form and introduces few extra fields (boolean handling, BASE64 images/files, nesting). django_api_forms.Form defines the format of the request and help you with: payload parsing (according to the Content-Type HTTP header) data validation and normalisation (using Django validators or custom clean_ method) BASE64 file/image upload construction of the basic validation response filling objects attributes (if possible, see exceptions) using setattr function (super handy for Django database models) Construction \u00b6 You can create form objects using class method Form.create_from_request(request: Request) -> Form which creates form instance from Django requests using appropriate parser from Content-Type HTTP header. from tests.testapp.forms import AlbumForm def my_view ( request ): form = AlbumForm . create_from_request ( request ) Library by default keeps configuration for handling: JSON (using jsong.loads ), msgpack (requires msgpack package). You can extend or override that behavior by setting the DJANGO_API_FORMS_PARSERS variable in your settings.py . Default settings for such variables are listed in the Example documentation page . During construction Form.dirty: List[str] property is populated with property keys presented in the obtained payload (dirty sluts!!). Mapping \u00b6 You can use Meta class in specific Form class with optional dictionary type attribute mapping = {} which allows you to map JSON attributes to Form attributes: JSON example { \"_name\" : \"Queen\" , \"formed\" : \"1970\" , \"has_award\" : true } Python representation from django.forms import fields from django_api_forms import BooleanField , Form class BandForm ( Form ): class Meta : mapping = { '_name' : 'name' } name = fields . CharField ( max_length = 100 ) formed = fields . IntegerField () has_award = BooleanField () Validation and normalisation \u00b6 This process is much more simple than in classic Django form. It consists of: Iterating over form attributes: calling Field.clean(value) method calling Form.clean_<field_name> method calling Form.add_error((field_name, ), error) in case of failures in clean methods if field is marked as dirty, normalized attribute is saved to Form.clean_data property Calling Form.clean method which returns final normalized values which will be presented in Form.clean_data (feel free to override it, by default does nothing, useful for conditional validation, you can still add errors u sing Form.add_error() ) Normalized data are available in Form.clean_data property (keys suppose to correspond with values from Form.dirty ). Validation errors are presented for each field in Form.errors: List[ValidationError] property after Form.is_valid() method is called. As was mentioned above, you can extend property validation or normalisation by creating form method like clean_<property_name> . You can add additional ValidationError objects using Form.add_error(field: Tuple, error: ValidationError) method. Result is final normalised value of the attribute. from django.forms import fields from django.core.exceptions import ValidationError from django_api_forms import Form class BookForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () def clean_title ( self ): if self . cleaned_data [ 'title' ] == \"The Hitchhiker's Guide to the Galaxy\" : self . add_error (( 'title' , ), ValidationError ( \"Too cool!\" , code = 'too-cool' )) return self . cleaned_data [ 'title' ] . upper () def clean ( self ): if self . cleaned_data [ 'title' ] == \"The Hitchhiker's Guide to the Galaxy\" and self . cleaned_data [ 'year' ] < 1979 : # Non field validation errors are present under key `$body` in Form.errors property raise ValidationError ( \"Is it you Doctor?\" , code = 'time-travelling' ) # The last chance to do some touchy touchy with the self.clean_data return self . cleaned_data Nesting \u00b6 Database relationships \u00b6 Populate objects \u00b6 IMPORTANT : Form fields FormField , FormFieldList , FileField and ImageField doesn't support this feature. You have to define populate_ method, if you want these fields populated. Form object method MyForm.populate(obj: Any, exclude: List[str] = None) which fills input obj using setattr according to the form fields. Only data present in clean_data property (data from request) will be populated. You can use it like this: from tests.testapp.forms import AlbumForm from tests.testapp.models import Album def my_view ( request ): form = AlbumForm . create_from_request ( request ) if not form . is_valid (): # Raise validation error pass album = Album () form . populate ( album ) album . save () Population strategies \u00b6 Library provides ability to change population strategy for each field using DJANGO_API_FORMS_POPULATION_STRATEGIES setting, or you can access settings directly form.settings.POPULATION_STRATEGIES . If there is no population strategy provided for field type, the DJANGO_API_FORMS_DEFAULT_POPULATION_STRATEGY is used. Default values are listed bellow: DJANGO_API_FORMS_POPULATION_STRATEGIES = { 'django_api_forms.fields.FormFieldList' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django_api_forms.fields.FileField' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django_api_forms.fields.ImageField' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django_api_forms.fields.FormField' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django.forms.models.ModelMultipleChoiceField' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django.forms.models.ModelChoiceField' : 'django_api_forms.population_strategies.ModelChoiceFieldStrategy' } DJANGO_API_FORMS_DEFAULT_POPULATION_STRATEGY = 'django_api_forms.population_strategies.BaseStrategy' BaseStrategy \u00b6 Object property is populated using 1:1 mapping and setattr function. IgnoreStrategy \u00b6 If this strategy is used, the target object is kept untouched. ModelChoiceField \u00b6 Field name is expected to have format like this: {field_name}(_{to_field_name})? so library is able to automatically resolve payload key postfix according to the to_field_name attribute. If there is no to_field_name provided, field name should be {field_name} or {field_name}_id . Normalised data are present in clean_data under key {field_name} (e.g. clean_data['{field_name}'] ). Few examples (normalized data are in clean_data['artist'] in all use-cases): from django.forms import ModelChoiceField from django_api_forms import Form from tests.testapp.models import Artist class MyFormNoPostfix ( Form ): artist = ModelChoiceField ( queryset = Artist . objects . all ()) class MyFormFieldName ( Form ): artist_name = ModelChoiceField ( queryset = Artist . objects . all (), to_field_name = 'name' ) class MyFormWithId ( Form ): artist_id = ModelChoiceField ( queryset = Artist . objects . all ()) Customization \u00b6 Creating custom strategy \u00b6 You can create your own population strategy by inheriting BaseStrategy and overriding it's __call__(self, field, obj, key: str, value) method. from django_api_forms.population_strategies import BaseStrategy class ExampleStrategy ( BaseStrategy ): def __call__ ( self , field , obj , key : str , value ): # Do your logic here setattr ( obj , key , value ) Override strategy \u00b6 You can override settings population strategies by creating your own population strategy in specific local From class using Meta class with optional attributes field_type_strategy = {} or field_strategy = {} : - field_type_strategy : Dictionary for overriding populate strategy on Form type attributes - field_strategy : Dictionary for overriding populate strategies on Form attributes from django.forms import fields from django_api_forms import BooleanField , Form class BandForm ( Form ): class Meta : field_type_strategy = { 'django_api_forms.fields.BooleanField' : 'app.population_strategies.ExampleStrategy1' } field_strategy = { 'formed' : 'app.population_strategies.ExampleStrategy2' } name = fields . CharField ( max_length = 100 ) formed = fields . IntegerField () has_award = BooleanField () Using populate_ method \u00b6 If you want to override population strategy for explicit field, you can define custom populate_{field} method inside your form class: from django.forms import fields from django_api_forms import Form , FormField , EnumField , DictionaryField from tests.testapp.models import Album , Artist from tests.testapp.forms import ArtistForm class AlbumForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () artist = FormField ( form = ArtistForm ) type = EnumField ( enum = Album . AlbumType , required = True ) metadata = DictionaryField ( fields . DateTimeField ()) def populate_year ( self , obj , value : int ) -> int : return 2020 def populate_artist ( self , obj , value : dict ) -> Artist : artist = Artist . objects . get_or_create ( name = value [ 'name' ] ) artist . genres = value [ 'genres' ] artist . members = value [ 'members' ] artist . save () return artist File uploads \u00b6","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"This library helps you to handle basic RESTful API use-cases with Django Forms fashion. Library kinda replaces django.forms.Form with django_api_forms.Form and introduces few extra fields (boolean handling, BASE64 images/files, nesting). django_api_forms.Form defines the format of the request and help you with: payload parsing (according to the Content-Type HTTP header) data validation and normalisation (using Django validators or custom clean_ method) BASE64 file/image upload construction of the basic validation response filling objects attributes (if possible, see exceptions) using setattr function (super handy for Django database models)","title":"Tutorial"},{"location":"tutorial/#construction","text":"You can create form objects using class method Form.create_from_request(request: Request) -> Form which creates form instance from Django requests using appropriate parser from Content-Type HTTP header. from tests.testapp.forms import AlbumForm def my_view ( request ): form = AlbumForm . create_from_request ( request ) Library by default keeps configuration for handling: JSON (using jsong.loads ), msgpack (requires msgpack package). You can extend or override that behavior by setting the DJANGO_API_FORMS_PARSERS variable in your settings.py . Default settings for such variables are listed in the Example documentation page . During construction Form.dirty: List[str] property is populated with property keys presented in the obtained payload (dirty sluts!!).","title":"Construction"},{"location":"tutorial/#mapping","text":"You can use Meta class in specific Form class with optional dictionary type attribute mapping = {} which allows you to map JSON attributes to Form attributes: JSON example { \"_name\" : \"Queen\" , \"formed\" : \"1970\" , \"has_award\" : true } Python representation from django.forms import fields from django_api_forms import BooleanField , Form class BandForm ( Form ): class Meta : mapping = { '_name' : 'name' } name = fields . CharField ( max_length = 100 ) formed = fields . IntegerField () has_award = BooleanField ()","title":"Mapping"},{"location":"tutorial/#validation-and-normalisation","text":"This process is much more simple than in classic Django form. It consists of: Iterating over form attributes: calling Field.clean(value) method calling Form.clean_<field_name> method calling Form.add_error((field_name, ), error) in case of failures in clean methods if field is marked as dirty, normalized attribute is saved to Form.clean_data property Calling Form.clean method which returns final normalized values which will be presented in Form.clean_data (feel free to override it, by default does nothing, useful for conditional validation, you can still add errors u sing Form.add_error() ) Normalized data are available in Form.clean_data property (keys suppose to correspond with values from Form.dirty ). Validation errors are presented for each field in Form.errors: List[ValidationError] property after Form.is_valid() method is called. As was mentioned above, you can extend property validation or normalisation by creating form method like clean_<property_name> . You can add additional ValidationError objects using Form.add_error(field: Tuple, error: ValidationError) method. Result is final normalised value of the attribute. from django.forms import fields from django.core.exceptions import ValidationError from django_api_forms import Form class BookForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () def clean_title ( self ): if self . cleaned_data [ 'title' ] == \"The Hitchhiker's Guide to the Galaxy\" : self . add_error (( 'title' , ), ValidationError ( \"Too cool!\" , code = 'too-cool' )) return self . cleaned_data [ 'title' ] . upper () def clean ( self ): if self . cleaned_data [ 'title' ] == \"The Hitchhiker's Guide to the Galaxy\" and self . cleaned_data [ 'year' ] < 1979 : # Non field validation errors are present under key `$body` in Form.errors property raise ValidationError ( \"Is it you Doctor?\" , code = 'time-travelling' ) # The last chance to do some touchy touchy with the self.clean_data return self . cleaned_data","title":"Validation and normalisation"},{"location":"tutorial/#nesting","text":"","title":"Nesting"},{"location":"tutorial/#database-relationships","text":"","title":"Database relationships"},{"location":"tutorial/#populate-objects","text":"IMPORTANT : Form fields FormField , FormFieldList , FileField and ImageField doesn't support this feature. You have to define populate_ method, if you want these fields populated. Form object method MyForm.populate(obj: Any, exclude: List[str] = None) which fills input obj using setattr according to the form fields. Only data present in clean_data property (data from request) will be populated. You can use it like this: from tests.testapp.forms import AlbumForm from tests.testapp.models import Album def my_view ( request ): form = AlbumForm . create_from_request ( request ) if not form . is_valid (): # Raise validation error pass album = Album () form . populate ( album ) album . save ()","title":"Populate objects"},{"location":"tutorial/#population-strategies","text":"Library provides ability to change population strategy for each field using DJANGO_API_FORMS_POPULATION_STRATEGIES setting, or you can access settings directly form.settings.POPULATION_STRATEGIES . If there is no population strategy provided for field type, the DJANGO_API_FORMS_DEFAULT_POPULATION_STRATEGY is used. Default values are listed bellow: DJANGO_API_FORMS_POPULATION_STRATEGIES = { 'django_api_forms.fields.FormFieldList' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django_api_forms.fields.FileField' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django_api_forms.fields.ImageField' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django_api_forms.fields.FormField' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django.forms.models.ModelMultipleChoiceField' : 'django_api_forms.population_strategies.IgnoreStrategy' , 'django.forms.models.ModelChoiceField' : 'django_api_forms.population_strategies.ModelChoiceFieldStrategy' } DJANGO_API_FORMS_DEFAULT_POPULATION_STRATEGY = 'django_api_forms.population_strategies.BaseStrategy'","title":"Population strategies"},{"location":"tutorial/#basestrategy","text":"Object property is populated using 1:1 mapping and setattr function.","title":"BaseStrategy"},{"location":"tutorial/#ignorestrategy","text":"If this strategy is used, the target object is kept untouched.","title":"IgnoreStrategy"},{"location":"tutorial/#modelchoicefield","text":"Field name is expected to have format like this: {field_name}(_{to_field_name})? so library is able to automatically resolve payload key postfix according to the to_field_name attribute. If there is no to_field_name provided, field name should be {field_name} or {field_name}_id . Normalised data are present in clean_data under key {field_name} (e.g. clean_data['{field_name}'] ). Few examples (normalized data are in clean_data['artist'] in all use-cases): from django.forms import ModelChoiceField from django_api_forms import Form from tests.testapp.models import Artist class MyFormNoPostfix ( Form ): artist = ModelChoiceField ( queryset = Artist . objects . all ()) class MyFormFieldName ( Form ): artist_name = ModelChoiceField ( queryset = Artist . objects . all (), to_field_name = 'name' ) class MyFormWithId ( Form ): artist_id = ModelChoiceField ( queryset = Artist . objects . all ())","title":"ModelChoiceField"},{"location":"tutorial/#customization","text":"","title":"Customization"},{"location":"tutorial/#creating-custom-strategy","text":"You can create your own population strategy by inheriting BaseStrategy and overriding it's __call__(self, field, obj, key: str, value) method. from django_api_forms.population_strategies import BaseStrategy class ExampleStrategy ( BaseStrategy ): def __call__ ( self , field , obj , key : str , value ): # Do your logic here setattr ( obj , key , value )","title":"Creating custom strategy"},{"location":"tutorial/#override-strategy","text":"You can override settings population strategies by creating your own population strategy in specific local From class using Meta class with optional attributes field_type_strategy = {} or field_strategy = {} : - field_type_strategy : Dictionary for overriding populate strategy on Form type attributes - field_strategy : Dictionary for overriding populate strategies on Form attributes from django.forms import fields from django_api_forms import BooleanField , Form class BandForm ( Form ): class Meta : field_type_strategy = { 'django_api_forms.fields.BooleanField' : 'app.population_strategies.ExampleStrategy1' } field_strategy = { 'formed' : 'app.population_strategies.ExampleStrategy2' } name = fields . CharField ( max_length = 100 ) formed = fields . IntegerField () has_award = BooleanField ()","title":"Override strategy"},{"location":"tutorial/#using-populate_-method","text":"If you want to override population strategy for explicit field, you can define custom populate_{field} method inside your form class: from django.forms import fields from django_api_forms import Form , FormField , EnumField , DictionaryField from tests.testapp.models import Album , Artist from tests.testapp.forms import ArtistForm class AlbumForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () artist = FormField ( form = ArtistForm ) type = EnumField ( enum = Album . AlbumType , required = True ) metadata = DictionaryField ( fields . DateTimeField ()) def populate_year ( self , obj , value : int ) -> int : return 2020 def populate_artist ( self , obj , value : dict ) -> Artist : artist = Artist . objects . get_or_create ( name = value [ 'name' ] ) artist . genres = value [ 'genres' ] artist . members = value [ 'members' ] artist . save () return artist","title":"Using populate_ method"},{"location":"tutorial/#file-uploads","text":"","title":"File uploads"}]}